---
title: xtt

theme: night
header-includes: <link rel=stylesheet href=style-extra.css>
history: true
...

# what is xtt?

:point_right: <https://www.cs.cmu.edu/~cangiuli/papers/xtt.pdf>

---

![](what_is_the_x.png) \
[(<https://twitter.com/jonmsterling/status/1407035198672343045>)]{.mini}


# intensional and extensional

## intensional type theory

:::defs
$$
\newcommand\Type{\mathord\bigstar}
\newcommand\Rule[3]{
  \frac{\begin{gathered}#2\end{gathered}}{#3}\:[\textsf{#1}]
}
\newcommand\Refl{\mathsf{refl}}
\newcommand\Subst{\mathsf{subst}}
$$
:::

- separate definitional & propositional equality

- "convertibility" $\equiv$ (e.g. $\alpha\beta\eta$ equality)
  vs "identity type" $=$

- explicit coercion over propositional equalities ($\Subst$)

  $$
  \begin{gathered}
  \Rule{id-f}{A : \Type \qquad x, y : A}{x =_A y : \Type}
  \qquad
  \Rule{id-i}{x : A}{\Refl_x : x =_A x}
  \\[1em]
  \Rule{id-e}{
    A : \Type \qquad
    P : A \to \Type \qquad
    x, y : A \qquad
    e : x = y \qquad
    p : P \; x
  }{
    \Subst_P \; e \; p : P \; y
  }
  \end{gathered}
  $$

:::notes
- the usual thing. agda, idris, coq, probably everything you've actually used
:::


## extensional type theory

- undecidable typechecking :scream_cat:

- "equality reflection"
  $$ \Rule{reflect}{e : x = y}{x \equiv y} $$

- nice properties like functional extensionality are **derivable**
  $$ \Rule{funext*}{x : A \vdash f \; x \equiv g \; x}{f \equiv g} $$

:::notes
- nuprl, lego, redprl, etc
- equality of two arbitrary terms is undecidable,
  and equality proofs can be invisibly required in typing due to `reflect`,
  hence undecidable typing
- in ETT based proof assistants you manipulate type derivations rather than
  just terms
- despite that, proofs can be less cluttered because any equality
  check can be made into a subgoal. e.g. no heterogeneous equality-type messes
- funext is a bigger deal than it may sound. e.g. w-types are unusable without it
:::


## so where does xtt fit in

- no equality reflection

- decidable type checking

- fun ext gained by other means

- like OTT but the specifics are different

- (no univalence)


# syntax (abbreviated)

:::defs
$$
\newcommand\EQ\Coloneqq
\newcommand\OR{\mathrel|}
\newcommand\ORR{\mathrel{\mathrlap{\mkern9mu|}{\hphantom\EQ}}}
$$
:::

## equality in cubical type theories

:::defs
$$
\newcommand\Eq{\mathsf{Eq}}
\newcommand\With{\mathsf{with}}
\newcommand\Goes\hookrightarrow
$$
:::

- a [pseudo]type called the **interval**, with **endpoints** called 0 and 1

- the interval might have extra structure or operations. not here though

- an equality is like a **function** from the interval to a normal type. \
  the images of 0 and 1 are the left and right of the equation. for example:
  - for $M : A, \quad \Refl_A \coloneqq (\lambda i. M) : M = M$
  - for $Q : Y = Z, \quad Q \; 0 = Y : A$, and $Q \; 1 = Z : A$.

- you can think of them as paths but that's less important than in hott


## regular terms

:::defs
$$
\newcommand\Fst{\mathsf{fst}}
\newcommand\Snd{\mathsf{snd}}
$$
:::

$$
\begin{aligned}
M, N, A, B
  &\EQ  x &\text{variable} \\
  &\ORR (x : A) \to B  \OR  \lambda x. M  \OR  M \; N
    & \text{functions} \\
  &\ORR (x : A) \times B  \OR  \langle M, N \rangle  \OR  \Fst \; M \OR \Snd \; M
    & \text{pairs} \\
  &\ORR \dotsb
\\[.75em]
\Gamma, \Delta
  &\EQ \cdot  \OR  \Gamma, x: A
    &\text{type context}
\end{aligned}
$$


## dimensions

- cube stuff (but no operations like $\wedge$ etc)

- used for equality

$$
\begin{aligned}
r, s
  &\EQ 0 \OR 1 \OR i
  &\text{dimension}
\\
\Psi, \Phi
  &\EQ \cdot \OR \Psi, i \OR \Psi, r = s
  &\text{dim. context (``cube'')}
\\[.75em]
M, N, A, B
  &\EQ  \dotsb & \text{(terms contd)} \\
  &\ORR \Eq_{i.A} \; M \; N  \OR  \lambda i. M  \OR  M \; r
    &\text{equality proofs} \\
  &\ORR [i. A] \downarrow^r_{r'} M
    &\text{coercion} \\
  &\ORR [i. A] \downarrow^r_{r'} M \; [s \; \With \; 0 \Goes j.N_0 \mid 1 \Goes j.N_1]
    &\text{composition}
\end{aligned}
$$

:::notes
- the subscript on $\Eq$ supports dependent equality
  - $\Eq_{i.A} \; M \; N$ is ok if \
    $M : A[0/i]$ and $N : A[1/i]$
- an equality proof can be applied to a dimension
  - if $Q: \Eq \; A \; B$, then \
    $Q \; 0 \mapsto A$ and \
    $Q \; 1 \mapsto B$
- coercion takes a term $M: A[0/i]$ \
  and has type $A[1/i]$
- a composition is like a coercion with extra constraints on its values
  for the ends of $s$
- typing coercions and compositions involves proving equalities at
  the endpoints as well as "conventional" type obligations
:::

# some type rules

$$ \Psi \mid \Gamma \vdash M : A $$

:::note
reminder: Ψ is cube, Γ is types, M is subj, A is type
:::

## inconsistency

$$
\Rule{false-ty}{\Psi \vdash 0 = 1}{\Psi \mid \Gamma \vdash M : A}
\qquad
\Rule{false-eq}{\Psi \vdash 0 = 1}{\Psi \mid \Gamma \vdash M = N : A}
\qquad
\text{etc}
$$

:::notes
if you can derive 0=1, then you're in an absurd case somewhere so you
can just stop
:::

## equalities

:::defs
$$
\newcommand\eps\varepsilon
\newcommand\Dim{\;\mathbf{dim}}
$$
:::

$$
\begin{gathered}
\Rule{eq-f}{
  \Psi, i \mid \Gamma \vdash A : \Type \qquad
  \overline{\Psi, i, i = \eps \mid \Gamma \vdash N_\eps : A}
}{
  \Psi \mid \Gamma \vdash \Eq_{i.A} \; N_0 \; N_1 : \Type
}
\\[.75em]
\Rule{eq-i}{
  \Psi, i \mid \Gamma \vdash M : A \qquad
  \overline{\Psi, i, i = \eps \mid \Gamma \vdash M = N_\eps : A}
}{
  \Psi \mid \Gamma \vdash \lambda i. M : \Eq_{i. A} \; N_0 \; N_1
}
\\[.75em]
\Rule{eq-e}{
  \Psi \vdash r \Dim \qquad
  \Psi, i \mid \Gamma \vdash A : \Type \\
  \overline{\Psi, i, i = \eps \mid \Gamma \vdash N_\eps : A} \qquad
  \Psi \mid \Gamma \vdash M : \Eq_{i. A} \; N_0 \; N_1
}{
  \Psi \mid \Gamma \vdash M \; r : A[r/i]
}
\end{gathered}
$$

:::notes
- an overline over a premise containing ε stands for two actual premises,
  one where ε=0 and one where ε=1
- eq-f is mostly expected, except that the type A of the Ns has a dimension variable,
  which can be used to give them different (but equal) types
- eq-i shows that an equality is an abstraction over a dimension i, whose
  body is a term equal to each N as i varies. \
  reflexivity $\Eq_{\_. A} \; M \; M$ is just \
  $\lambda i. M$.
- eq-e applies one of these abstractions, substituting in the type, and when
  β reducing, in the body. when r is 0 or 1 this results in one of the Ns
:::


## coercions

$$
\begin{gathered}
\Rule{coe}{
  \Psi \vdash r, r' \Dim \qquad
  \Psi, i \mid \Gamma \vdash A : \Type \qquad
  \Psi \mid \Gamma \vdash M : A[r/i]
}{
  \Psi \mid \Gamma \vdash [i. A] \downarrow^r_{r'} M : A[r'/i]
}
\\[.75em]
\Rule{coe-b}{
  \Psi \mid \Gamma \vdash M : A[r/i]
}{
  \Psi \mid \Gamma \vdash ([i. A] \downarrow^r_r M) = M : A[r/i]
}
\end{gathered}
$$

:::notes
- a coercion along a type equality takes a term \
  $M: A[r/i]$ to $M: A[r'/i]$ for some
  line of types $i. A$ \
  (i.e. an equality $\lambda i. A$)
- if the beginning and the end are the same
  the coercion just computes away
:::


## :sparkles: boundary separation :sparkles:

$$
\begin{gathered}
\Rule{bsep}{
  \Psi \vdash r \Dim \qquad
  \overline{\Psi, r = \eps \mid \Gamma \vdash M = N : A}
}{
  \Psi \mid \Gamma \vdash M = N : A
}
\end{gathered}
$$

- thanks to this rule, equalities are always defined by their
  endpoints
- in other words there is only (at most) one proof of
  $A = B$
- so you still have UIP, proofs can always be erased,
  matching with K is (probably) still fine, etc

:::notes
- when you're trying to prove an equality you
  can do so by repeated applications of this rule
  to assign 0 or 1 to each dim variable, and checking
  under each of these assignments which is consistent
:::


# examples

## funext example

:::defs
$$
\newcommand\DD{\texttt}
\newcommand\VV{\mathit}
\newcommand\Nat{\mathbb{N}}
$$
:::

:::incremental
- $\DD{f}, \DD{g}: (x: A) \to B \; x$

- $\DD{fg} : (x : A) \to \Eq_{\_. B \; x} (f \; x) (g \; x)$

- $\lambda i. \lambda x. \DD{fg} \; x \; i : \Eq_{\_. (x: A) \to B \; x} \; f \; g$
:::


## coercion example

:::incremental
- $\DD{zeroR} : (m : \Nat) \to m = m + \DD{Z}$
  - $\DD{zeroR} \; m \; 0 \mapsto m \qquad
     \DD{zeroR} \; m \; 1 \mapsto m+\DD{Z}$

- $\DD{Vec} : \Type \to \Nat \to \Type$

- $\VV{xs}: \DD{Vec} \; \Nat \; n$

- $[i. \DD{Vec} \; \Nat \; (\DD{zeroR} \; n \; i)] \downarrow^0_1 \VV{xs} :
      \DD{Vec} \; \Nat \; (n + \DD{Z})$
  - $\lambda i. \DD{Vec} \; \Nat \; (\DD{zeroR} \; n \; i) :
      \Eq_{\_. \Type} \; (\DD{Vec} \; \Nat \; n) \;
                         (\DD{Vec} \; \Nat \; (n + \DD{Z}))$
:::


:::notes
- i couldn't think of a good example of a composition, sorry. it seems like
  compositions would mostly show up from computation, rather than being
  used directly.
:::


# conclusion

## xtt in one slide

- basically OTT 2
- extensionality but still decidable
  - (**propositional** extensionality, not definitional)
- cubes :ice_cube: :ice_cube: :ice_cube:
- boundary separation
- i think it's kinda cool anyway


## should we add this to juvix?

- no i don't think so
  - it's still pretty complicated
  - it still relies on a closed type universe + type case \
    but i think only in "zero-usage" places
